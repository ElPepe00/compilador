/*-------------------------------------------------------------*
 * Parser.cup - Analitzador Sintactic i Semantic
 *-------------------------------------------------------------*/
 
 /*
  * Autor: Josep Oliver Vallespir
  * DNI: 78222663P
  * Curs: 2025-2026
  * Assignatura: Compiladors I
  */
  
package frontend.sintactic;

import java.util.ArrayList;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

import frontend.gestor_errors.*;
import frontend.ast.*;
import frontend.taula_simbols.TipusSimbol;

/* --- CODI DEL PARSER --- */
parser code {:

	// Metode que es crida quan hiha un error sintactic
    @Override
    public void syntax_error(Symbol token_actual) {
        String missatge;
        if(token_actual.value == null) {
            missatge = "Error de sintaxi: El token actual es null, falta algun token.";
        }else{
            missatge = "Error de sintaxi. El valor del token es: [" + token_actual.value + "] i no es correcte.";
        }
        this.report_error(missatge, token_actual);
    }
	
	// Metode que registra els errors sintactics
    @Override
    public void report_error(String missatge, Object token) {
        GestorError.afegirError(new MissatgeError(
												TipusError.SINTACTIC, 		// error de tipus sintactic
												((Symbol) token).left,		// linia del token
												-1,							// columna del token, -1
												missatge));					// missatge descriptiu
    }

	// Metode que gestiona els errors fatals de sintaxi
    @Override
    public void report_fatal_error(String missatge, Object info) {
		System.err.println("Error fatal de sintaxi: " + missatge);
        this.report_fatal_error(missatge, info);
    }

	// Metode que es crida quan es produeix un error no recuperable de sintaxi del parser
    @Override
    public void unrecovered_syntax_error(Symbol token_actual){
		String missatge = "Error greu de sintaxi a la linia: " + token_actual.left + ".";
		this.report_error(missatge, token_actual);
    }
:};

/*---------------------------------------------*/
/*    		    	TERMINALS 			       */
/*---------------------------------------------*/
/* Inici i fi de programa */
terminal Object PROGRAMA;
terminal Object PROGRAMA_FI;

/* Subprograma */
terminal Object FUNCIO;
terminal Object FUNCIO_FI;
terminal Object RETURN;

/* Condicional i bucles */
terminal Object IF;
terminal Object IF_FI;
terminal Object ELSE;
terminal Object ELSE_FI;
terminal Object WHILE;
terminal Object WHILE_FI;
terminal Object DO;
terminal Object DOWHILE;

/* Entrada i sortida */
terminal Object LLEGIR;
terminal Object IMPRIMIR;

/* Tipus de dada*/
terminal Object CONSTANT;
terminal Object INT;
terminal Object CHAR;
terminal Object BOOL;
terminal Object TAULA;

/* Operadors relacionals */
terminal Object IGUAL;
terminal Object NOIGUAL;
terminal Object MENOR;
terminal Object MAJOR;

/* Operadors logics */
terminal Object OR;
terminal Object AND;
terminal Object NOT;

/* Operadors aritmetics */
terminal Object SUMA;
terminal Object RESTA;
terminal Object MULT;
terminal Object DIV;

/* Operador assignacio */
terminal Object ASSIGN;

/* Delimitadors */
terminal Object COMA;
terminal Object LPAREN;
terminal Object RPAREN;
terminal Object LBRACKET;
terminal Object RBRACKET;

/* Comen√ßament i Fi de linea */
terminal Object BEGIN;
terminal Object FILINEA;

/* Booleans */
terminal Object BTRUE;
terminal Object BFALSE;

/* Terminals diferents */
terminal String ID;
terminal String NUMERO;
terminal Character CARACTER;

terminal Object UMINUS; //------------------------------------------------------------------------------------- terminal UMINUS

/*---------------------------------------------*/
/*    		      NO TERMINALS 			       */
/*---------------------------------------------*/
non terminal Object
  Peplang, Globs, Decl_glob, Decl_glob_taula,
  Funcs, Func, Returnv, ParamsOpt, ParamList, Param, Returnfi,
  Main, Elements, Element,
  Decl_loc, DeclTailEscalar,
  Decl_taula, DeclTailTaulaInt, DeclTailTaulaChar, DeclTailTaulaBool,
  ArrayLitInt, IntElems,
  ArrayLitChar, CharElems,
  ArrayLitBool, BoolElems,
  Instr, AssignacioRead, Assignacio,
  LValue, Ref,
  If_prog, If_fin, While_prog, DoWhile_prog,
  Crida_proc, Crida_func, CridaBase,
  ArgsPrint, ArgsOpt, ArgList, ExpressOpt,
  Cond, Express,
  Num, CharLit, BoolLit,
  Tipusv;
  
  non terminal ArrayList<Integer> Dims;

/*---------------------------------------------*/
/*    		      PRECEDENCIA			       */
/*---------------------------------------------*/
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc IGUAL;
precedence nonassoc NOIGUAL;
precedence nonassoc MAJOR;
precedence nonassoc MENOR;
precedence left SUMA;
precedence left RESTA;
precedence left MULT;
precedence left DIV;
precedence right NOT, UMINUS; //--------------------------------------------------------------------------------- precedencia

/*---------------------------------------------*/
/*    		      PRODUCCIONS			       */
/*---------------------------------------------*/
// Punt d'entrada
start with Peplang;

// Produccio inicial que permet posar declaracions globals,
// funcions(subprogrames) i el programa pricipal
Peplang 			::= Globs:g Funcs:f Main:m															{: RESULT = new Node_Peplang((Node_Globs)g, (Node_Funcs)f, (Node_Main)m); :}
					;

// Declaracions globals fora de programa principal
// nomes poden ser constants (normes de peplang)
Globs				::= Globs:g Decl_glob:d																{: RESULT = new Node_Globs((Node_Globs)g, (Node_Decl_glob)d); :}
					|																					{: RESULT = null; :}
					;

// constants escalares i TAULES tipades
Decl_glob           ::= CONSTANT Tipusv:t ID:id ASSIGN Express:e FILINEA								{: RESULT = new Node_Decl_glob_escalar((Node_Tipusv)t, (String)id, (Node_Express)e); :}
                    | Decl_glob_taula:d FILINEA															{: RESULT = (Node_Decl_glob_taula)d; :}	
					;

Decl_glob_taula     ::= CONSTANT TAULA INT ID:id Dims:d DeclTailTaulaInt:tail							{: RESULT = new Node_Decl_glob_taula("INT", (String)id, d, (Node_DeclTailTaulaInt)tail); :}
                    | CONSTANT TAULA CHAR ID:id Dims:d DeclTailTaulaChar:tail							{: RESULT = new Node_Decl_glob_taula("CARACTER", (String)id, d, (Node_DeclTailTaulaChar)tail); :}
                    | CONSTANT TAULA BOOL ID:id Dims:d DeclTailTaulaBool:tail							{: RESULT = new Node_Decl_glob_taula("BOOL", (String)id, d, (Node_DeclTailTaulaBool)tail); :}
					;

// Per multidimensionalitat dels arrays
Dims 				::= LBRACKET Num:n RBRACKET															{: 
																											ArrayList<Integer> l = new ArrayList<>(); 
																											l.add(((Node_Num)n).getValorEnter());
																											RESULT = l; 
																										:}
					| Dims:l LBRACKET Num:n RBRACKET
																										{: 
																											l.add(((Node_Num)n).getValorEnter()); 
																											RESULT = l; 
																										:}
					;
// --- FUNCIONS
Funcs               ::= Funcs:fs Func:f																	{: RESULT = new Node_Funcs((Node_Funcs)fs, (Node_Func)f); :}
                    |																					{: RESULT = null; :}
					;

Func                ::= FUNCIO Returnv:rv ID:id LPAREN ParamsOpt:p RPAREN BEGIN Elements:e Returnfi:ret FUNCIO_FI		
																										{: RESULT = new Node_Func((Node_Returnv)rv, (String)id, (Node_ParamsOpt)p, (Node_Elements)e, (Node_Returnfi)ret); :}
					;

Returnv            	::= Tipusv:t 																		{: RESULT = new Node_Returnv((Node_Tipusv)t); :}
					|																					{: RESULT = null; :}
					;
					
ParamsOpt          	::= ParamList:p																		{: RESULT = new Node_ParamsOpt((Node_ParamList)p); :}
					|																					{: RESULT = null; :}
					;
					
ParamList          	::= Param:p																			{: RESULT = new Node_ParamList(null, (Node_Param)p); :}
					| ParamList:pl COMA Param:p															{: RESULT = new Node_ParamList((Node_ParamList)pl, (Node_Param)p); :}
					;
					
Param              	::= Tipusv:t ID:id																	{: RESULT = new Node_Param((Node_Tipusv)t, (String)id, false); :}
					| TAULA INT ID:id LBRACKET RBRACKET													{: RESULT = new Node_Param(new Node_Tipusv(TipusSimbol.INT), (String)id, true); :}
					| TAULA CHAR ID:id LBRACKET RBRACKET												{: RESULT = new Node_Param(new Node_Tipusv(TipusSimbol.CHAR), (String)id, true); :}
					| TAULA BOOL ID:id LBRACKET RBRACKET												{: RESULT = new Node_Param(new Node_Tipusv(TipusSimbol.BOOL), (String)id, true); :}
					;
					
Returnfi           	::= RETURN ExpressOpt:e FILINEA 													{: RESULT = new Node_Returnfi((Node_Express)e); :}
					|																					{: RESULT = null; :}
					;

// --------------------------------------------------------
// --- PROGRAMA
Main               	::= PROGRAMA BEGIN Elements:e PROGRAMA_FI											{: RESULT = new Node_Main((Node_Elements)e); :}
					;

// --- BLOCS (decl + instruccions barrejades) 
Elements           	::= Elements:es Element:e															{: RESULT = new Node_Elements((Node_Elements)es, (Node_Element)e); :}
					|																					{: RESULT = null; :}
					;

Element            	::= Decl_loc:dl																		{: RESULT = new Node_Element("decl", (Node_Decl_loc)dl); :}
					| Instr:i																			{: RESULT = new Node_Element("instr", (Node_Instr)i); :}
					;

// --- DECLARACIONS LOCALS
// Escalares
Decl_loc           	::= Tipusv:t ID:id DeclTailEscalar:dte FILINEA										{: RESULT = new Node_Decl_loc_escalar((Node_Tipusv)t, (String)id, (Node_DeclTailEscalar)dte); :}
                    | Decl_taula:dt FILINEA																{: RESULT = (Node_Decl_loc_taula)dt; :}
					;
					
DeclTailEscalar    	::= ASSIGN Express:e																{: RESULT = new Node_DeclTailEscalar("assign", (Node_Express)e); :}
                    | ASSIGN LLEGIR LPAREN RPAREN														{: RESULT = new Node_DeclTailEscalar("llegir", null); :}
                    |																					{: RESULT = null; :}
					;

// TAULES tipades locals 
Decl_taula         	::= TAULA INT ID:id Dims:d DeclTailTaulaInt:tail									{: RESULT = new Node_Decl_loc_taula("INT", (String)id, d, (Node_DeclTailTaulaInt)tail); :}
                    | TAULA CHAR ID:id Dims:d DeclTailTaulaChar:tail									{: RESULT = new Node_Decl_loc_taula("CARACTER", (String)id, d, (Node_DeclTailTaulaChar)tail); :}
                    | TAULA BOOL ID:id Dims:d DeclTailTaulaBool:tail									{: RESULT = new Node_Decl_loc_taula("BOOL", (String)id, d, (Node_DeclTailTaulaBool)tail); :}
					;

DeclTailTaulaInt   	::= ASSIGN ArrayLitInt:a 															{: RESULT = new Node_DeclTailTaulaInt((Node_ArrayLitInt)a); :}
					|																					{: RESULT = null; :}
					;
					
DeclTailTaulaChar  	::= ASSIGN ArrayLitChar:a 															{: RESULT = new Node_DeclTailTaulaChar((Node_ArrayLitChar)a); :}
					|																					{: RESULT = null; :}
					;
					
DeclTailTaulaBool  	::= ASSIGN ArrayLitBool:a 															{: RESULT = new Node_DeclTailTaulaBool((Node_ArrayLitBool)a); :}
					|																					{: RESULT = null; :}
					;

// Literals de taula per tipus (elements literals del mateix tipus)
	// INT
ArrayLitInt        	::= LBRACKET IntElems:ie RBRACKET													{: RESULT = new Node_ArrayLitInt((Node_IntElems)ie); :}
					;
					
IntElems           	::= Num:n																			{: RESULT = new Node_IntElems(null, (Node_Num)n); :}
					| IntElems:ie COMA Num:n															{: RESULT = new Node_IntElems((Node_IntElems)ie, (Node_Num)n); :}
					;

	// CHAR
ArrayLitChar       	::= LBRACKET CharElems:ce RBRACKET													{: RESULT = new Node_ArrayLitChar((Node_CharElems)ce); :}											
					;                                                                                                                                                                  
                                                                                                        
CharElems          	::= CharLit:c																		{: RESULT = new Node_CharElems(null, (Node_CharLit)c); :}
					| CharElems:ce COMA CharLit:cl 														{: RESULT = new Node_CharElems((Node_CharElems)ce, (Node_CharLit)cl); :}
					;

	// BOOL
ArrayLitBool       	::= LBRACKET BoolElems:be RBRACKET													{: RESULT = new Node_ArrayLitBool((Node_BoolElems)be); :}
					;                                                                                                                                                                   
                                                                                                        
BoolElems          	::= BoolLit:b																		{: RESULT = new Node_BoolElems(null, (Node_BoolLit)b); :}
					| BoolElems:be COMA BoolLit:b														{: RESULT = new Node_BoolElems((Node_BoolElems)be, (Node_BoolLit)b); :}
					;

/* --- INSTRUCCIONS --- */
Instr              	::= If_prog:ifp																		{: RESULT = new Node_Instr((Node_If_prog)ifp); :}
                    | While_prog:wh																		{: RESULT = new Node_Instr((Node_While_prog)wh); :}
                    | DoWhile_prog:dw																	{: RESULT = new Node_Instr((Node_DoWhile_prog)dw); :}
                    | AssignacioRead FILINEA:ar 														{: RESULT = new Node_Instr((Node_AssignacioRead)ar); :}
                    | Assignacio:a FILINEA 																{: RESULT = new Node_Instr((Node_Assignacio)a); :}
                    | Crida_proc:c FILINEA																{: RESULT = new Node_Instr((Node_Crida_proc)c); :}
					;

AssignacioRead     	::= LValue:lv ASSIGN LLEGIR LPAREN RPAREN											{: RESULT = new Node_AssignacioRead((Node_LValue)lv); :}
					;
Assignacio        	::= LValue:lv ASSIGN Express:e														{: RESULT = new Node_Assignacio((Node_LValue)lv, (Node_Express)e); :}
					;

/* LHS: variable o element de taula (admet multiples [expr]) */
LValue             	::= Ref:r																			{: RESULT = new Node_LValue((Node_Ref)r); :}
					;
					
Ref                	::= ID:id																			{: RESULT = new Node_Ref((String)id); :}
                    | Ref:r LBRACKET Express:e RBRACKET													{: RESULT = new Node_Ref((Node_Ref)r, (Node_Express)e); :}
					;

/* --- CONTROL DE FLUX --- */
If_prog            	::= IF LPAREN Cond:c RPAREN BEGIN Elements:e If_fin:f								{: RESULT = new Node_If_prog((Node_Cond)c, (Node_Elements)e, (Node_If_fin)f); :}
					;
If_fin             	::= IF_FI																			{: RESULT = new Node_If_fin(null); :}
					| ELSE BEGIN Elements:e ELSE_FI														{: RESULT = new Node_If_fin((Node_Elements)e); :}
					;
					
While_prog         	::= WHILE LPAREN Cond:c RPAREN BEGIN Elements:e WHILE_FI							{: RESULT = new Node_While_prog((Node_Cond)c, (Node_Elements)e); :}
					;
					
DoWhile_prog       	::= DO BEGIN Elements:e DOWHILE LPAREN Cond:c RPAREN FILINEA						{: RESULT = new Node_DoWhile_prog((Node_Elements)e, (Node_Cond)c); :}
					;

/* --- CRIDES --- */
Crida_proc         	::= IMPRIMIR LPAREN ArgsPrint:ap RPAREN												{: RESULT = new Node_Crida_proc((Node_ArgsPrint)ap, null); :}
                    | CridaBase:c																		{: RESULT = new Node_Crida_proc(null, (Node_CridaBase)c); :}
					;

Crida_func         	::= CridaBase:c																		{: RESULT = new Node_Crida_func((Node_CridaBase)c); :}
					;

CridaBase          	::= ID:id LPAREN ArgsOpt:a RPAREN													{: RESULT = new Node_CridaBase((String)id, (Node_ArgsOpt)a); :}
					;

ArgsPrint          	::= ArgList:al																		{: RESULT = new Node_ArgsPrint((Node_ArgList)al); :}
					|																					{: RESULT = null; :}
					;
					
ArgsOpt            	::= ArgList:al																		{: RESULT = new Node_ArgsOpt((Node_ArgList)al); :}
					|																					{: RESULT = null; :}
					;
					
ArgList            	::= Express:e																		{: RESULT = new Node_ArgList(null, (Node_Express)e); :}
					| ArgList:a COMA Express:e															{: RESULT = new Node_ArgList((Node_ArgList)a, (Node_Express)e); :}
					;
					
ExpressOpt         	::= Express:e 																		{: RESULT = (Node_Express)e; :}
					|																					{: RESULT = null; :}
					;

/* --- EXPRESSIONS --- */
Cond               	::= Express:e																		{: RESULT = new Node_Cond((Node_Express)e); :}
					;

Express            	::= Express:e1 SUMA Express:e2														{: RESULT = new Node_Express(Operador.SUMA, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 RESTA Express:e2														{: RESULT = new Node_Express(Operador.RESTA, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 MULT Express:e2														{: RESULT = new Node_Express(Operador.MULT, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 DIV Express:e2															{: RESULT = new Node_Express(Operador.DIV, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 AND Express:e2															{: RESULT = new Node_Express(Operador.AND, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 OR  Express:e2															{: RESULT = new Node_Express(Operador.OR, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 IGUAL Express:e2														{: RESULT = new Node_Express(Operador.IGUAL, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 NOIGUAL Express:e2														{: RESULT = new Node_Express(Operador.NOIGUAL, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 MENOR Express:e2														{: RESULT = new Node_Express(Operador.MENOR, (Node_Express)e1, (Node_Express)e2); :}
                    | Express:e1 MAJOR Express:e2														{: RESULT = new Node_Express(Operador.MAJOR, (Node_Express)e1, (Node_Express)e2); :}
                    | NOT Express:e                          											{: RESULT = new Node_Express(Operador.NOT, (Node_Express)e); :}
                    | RESTA Express:e 																	{: RESULT = new Node_Express(Operador.UMINUS, (Node_Express)e); :}
					  %prec UMINUS 														
                    | LPAREN Express:e RPAREN															{: RESULT = new Node_Express(Operador.PAREN, (Node_Express)e); :}
                    | Ref:r                                   											{: RESULT = new Node_Express(Operador.REF, (Node_Ref)r); :}
                    | Num:n																				{: RESULT = new Node_Express(Operador.NUM, (Node_Num)n); :}
					| CharLit:c																			{: RESULT = new Node_Express(Operador.CHAR, (Node_CharLit)c); :}
					| BoolLit:b																			{: RESULT = new Node_Express(Operador.BOOL, (Node_BoolLit)b); :}
                    | Crida_func:c                           											{: RESULT = new Node_Express(Operador.CRIDA, (Node_Crida_func)c); :}
					;
					
/* --- LITERALS I TIPUS --- */
Num                	::= NUMERO:n																		{: RESULT = new Node_Num((String)n); :}
					;
					
CharLit            	::= CARACTER:c																		{: RESULT = new Node_CharLit((Character)c); :}
					;
					
BoolLit            	::= BTRUE																			{: RESULT = new Node_BoolLit("true"); :}
					| BFALSE																			{: RESULT = new Node_BoolLit("false"); :}
					;

Tipusv             	::= INT																				{: RESULT = new Node_Tipusv(TipusSimbol.INT); :}
					| CHAR																				{: RESULT = new Node_Tipusv(TipusSimbol.CHAR); :}
					| BOOL																				{: RESULT = new Node_Tipusv(TipusSimbol.BOOL); :}
					;


